# Simple protocol system to deal with network events in an extensible way.

# A lot of this is very draft-y so feel free to change.

import json


class PacketHandler:
    """
    Adds functions for event handling incoming packets.
    """

    def handle_message(self, data, address):
        """
        Handle a message packet.
        :param data: Message data.
        :param address: Origin address of data.
        :return: Nothing.
        """
        raise NotImplementedError("Please implement this method.")

    def handle_command(self, data, address):
        """
        Handle a command packet.
        :param data: Command data.
        :param address: Origin address of data.
        :return: Nothing.
        """
        raise NotImplementedError("Please implement this method.")

    def handle_config(self, data, address):
        """

        Handle a config packet
        :param data: Config data.
        :param address: Origin address of data.
        :return: Nothing.
        """
        raise NotImplementedError("Please implement this method.")

    def handle_packet(self, packet, address):
        """
        Our "Packets" could have a form like:
        {
            "kind": "message",
            "data": { ... }
        }
        Where the data key contains an arbitrary information relevant to the type.
        For example a message packet may have data fields like time sent, or the message body, and a command packet
        would contain information like the command to execute and parameters.

        TODO: to save data we could make the "types" single digit byte objects or something and then create a mapping
        like 0 - message, 1 - command etc, but we can implement that later.

        TODO: define message "kinds" as constants for easy changing.

        TODO: could take the bytes object and convert it using json in the protocol to make all json-dealing occur
        within this handler (for proper segregation).

        :param packet: The packet to handle.
        :param address: address packet is from.
        :return: Nothing. Calls relevant function to handle the appropriate packet type.
        """
        funcs = {
            "message": self.handle_message,
            "command": self.handle_command,
            "config": self.handle_config
        }
        packet = json.loads(packet)
        try:
            funcs[packet["kind"]](packet["data"], address)
        except KeyError:
            if packet is None:
                packet = {"kind": None, "warn": "Generated by exception."}
            if "kind" not in packet:
                packet["kind"] = None
            print("Ignored packet with invalid kind '{}'.\nFull packet: \"{}\"".format(packet["kind"], packet))


class PacketBuilder:
    """
    Adds functions for constructing valid packets which can be interpreted in our client-server model.
    """

    @staticmethod
    def build_message(body):
        """
        Build a message packet.
        :param body: Body of the message.
        :return: Bytes object ready to send through socket interface.
        """
        return json.dumps({"kind": "message", "data": {"body": body}}).encode()

    # TODO: should be rewritten to allow only specific config fields.
    # TODO: packets with extra/invalid fields should be thrown out.
    # TODO: see handle_config
    @staticmethod
    def build_config(cfg):
        """
        Build a config packet.
        :param cfg: The configuration dictionary.
        :return: Bytes object ready to send through socket interface.
        """
        return json.dumps({"kind": "config", "data": cfg}).encode()
